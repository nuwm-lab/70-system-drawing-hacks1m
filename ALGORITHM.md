# Алгоритм побудови графіка функції

## Завдання
Побудувати графік функції **y = (x + cos(2x)) / (x + 2)** для діапазону **0.2 ≤ x ≤ 10** з кроком **Δx = 0.8** з автоматичним масштабуванням при зміні розмірів вікна.

## Використані класи з System.Drawing

### 1. **Form** (базовий клас для вікна)
- `GraphForm` успадковує `System.Windows.Forms.Form`
- Властивості:
  - `Text` - заголовок вікна
  - `BackColor` - колір фону
  - `DoubleBuffered` - подвійна буферизація для усунення мерехтіння
  - `ClientSize` - розмір клієнтської області

### 2. **Graphics** (малювання)
- Отримується з `PaintEventArgs` в методі `OnPaint`
- Властивість `SmoothingMode` - згладжування ліній (AntiAlias)
- Методи:
  - `DrawLine()` - малювання ліній (осі, поділки)
  - `DrawLines()` - малювання полілінії (графік)
  - `FillEllipse()` - малювання точок даних
  - `DrawRectangle()` - рамка області графіка
  - `DrawString()` - підписи осей
  - `MeasureString()` - вимірювання розміру тексту

### 3. **Pen** (олівець для ліній)
- `Pen(Color, width)` - колір та товщина
- Використовується для осей, сітки та графіка

### 4. **Brush** (пензель для заповнення)
- `Brushes.Black` - для тексту
- `Brushes.Red` - для точок даних

### 5. **Font** (шрифт)
- `Font("Segoe UI", 9)` - для підписів осей

### 6. **Rectangle** і **Padding**
- `ClientRectangle` - повна область вікна
- `Padding(50)` - відступи для підписів осей
- Обчислення `plotRect` - область для графіка

### 7. **PointF** (точка з float координатами)
- Зберігає координати точок графіка на екрані

## Алгоритм роботи програми

### 1. Ініціалізація форми (конструктор)
```
1. Встановити заголовок вікна
2. Встановити білий фон
3. Увімкнути подвійну буферизацію
4. Підписатись на події Resize для перемалювання
5. Встановити початковий розмір 800×600
```

### 2. Обробка зміни розміру вікна
```
OnResize():
    1. Викликати базовий метод
    2. Викликати Invalidate() для перемалювання
```

### 3. Малювання графіка (OnPaint)

#### 3.1. Обчислення значень функції
```
1. Створити списки xs[], ys[]
2. Обчислити кількість кроків: steps = (xEnd - xStart) / dx
3. ДЛЯ кожного кроку i від 0 до steps:
    x = xStart + i × dx
    y = (x + cos(2x)) / (x + 2)
    Додати x до xs[]
    Додати y до ys[]
```

#### 3.2. Визначення діапазонів
```
1. xmin = xStart, xmax = xEnd
2. ymin = мінімальне значення з ys[]
3. ymax = максимальне значення з ys[]
4. ЯКЩО ymax ≈ ymin:
    ymax = ymin + 1
    ymin = ymin - 1
```

#### 3.3. Обчислення області графіка
```
plotRect = Rectangle(
    x: margin.Left,
    y: margin.Top,
    width: ClientWidth - margin.Left - margin.Right,
    height: ClientHeight - margin.Top - margin.Bottom
)
```

#### 3.4. Перетворення координат (математичні → екранні)
```
ДЛЯ кожної точки (x, y):
    px = plotRect.Left + (x - xmin) / (xmax - xmin) × plotRect.Width
    py = plotRect.Bottom - (y - ymin) / (ymax - ymin) × plotRect.Height
    Додати PointF(px, py) до списку pts[]
```

**Пояснення:**
- По X: лінійне масштабування від xmin..xmax до 0..plotRect.Width
- По Y: інвертоване масштабування (0 зверху, тому віднімаємо від Bottom)

#### 3.5. Малювання осей координат
```
1. Обчислити позицію осі Y (x = 0):
    ЯКЩО 0 входить в діапазон [xmin, xmax]:
        x0 = plotRect.Left + (0 - xmin) / (xmax - xmin) × plotRect.Width
    ІНАКШЕ:
        x0 = лівий або правий край

2. Обчислити позицію осі X (y = 0):
    ЯКЩО 0 входить в діапазон [ymin, ymax]:
        y0 = plotRect.Bottom - (0 - ymin) / (ymax - ymin) × plotRect.Height
    ІНАКШЕ:
        y0 = верхній або нижній край

3. Намалювати горизонтальну лінію (вісь X) на y0
4. Намалювати вертикальну лінію (вісь Y) на x0
```

#### 3.6. Малювання поділок та підписів осі X
```
ДЛЯ x від xmin до xmax з кроком dx:
    1. tx = plotRect.Left + (x - xmin) / (xmax - xmin) × plotRect.Width
    2. Намалювати вертикальну рисочку на (tx, y0)
    3. Створити текст: x.ToString("0.##")
    4. Виміряти ширину тексту
    5. Намалювати текст центрований під рисочкою
```

#### 3.7. Малювання поділок та підписів осі Y
```
ticks = 5
ДЛЯ k від 0 до ticks:
    1. yv = ymin + (ymax - ymin) × k / ticks
    2. ty = plotRect.Bottom - (yv - ymin) / (ymax - ymin) × plotRect.Height
    3. Намалювати горизонтальну рисочку на (x0, ty)
    4. Створити текст: yv.ToString("0.###")
    5. Виміряти ширину тексту
    6. Намалювати текст зліва від рисочки
```

#### 3.8. Малювання графіка та точок
```
1. ЯКЩО pts.Count >= 2:
    Намалювати полілінію синім кольором товщиною 2
2. ДЛЯ кожної точки p в pts[]:
    Намалювати червоне коло радіусом 3 в точці p
```

#### 3.9. Малювання рамки
```
Намалювати прямокутник навколо plotRect сірим кольором
```

## Механізм автоматичного масштабування

1. **Подія Resize** викликає метод `Invalidate()`
2. `Invalidate()` позначає форму для перемалювання
3. Windows викликає `OnPaint()` з новими розмірами
4. `ClientRectangle` автоматично містить нові розміри
5. Всі координати перераховуються відносно нового `plotRect`
6. Графік малюється в новому масштабі

## Ключові особливості реалізації

### Уникнення похибок округлення
```csharp
int steps = (int)Math.Round((xEnd - xStart) / dx);
for (int i = 0; i <= steps; i++)
{
    double x = xStart + i * dx;
    // замість: for (double x = xStart; x <= xEnd; x += dx)
}
```

### Захист від поділу на нуль
```csharp
if (Math.Abs(ymax - ymin) < 1e-9)
{
    ymax = ymin + 1;
    ymin = ymin - 1;
}
```

### Подвійна буферизація
```csharp
DoubleBuffered = true; // усуває мерехтіння при зміні розмірів
```

### Згладжування ліній
```csharp
g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;
```

## Часова складність
- Обчислення точок: O(n), де n = кількість кроків ≈ 13
- Малювання: O(n) для графіка + O(m) для поділок
- Загалом: O(n) - лінійна

## Просторова складність
- O(n) для зберігання координат точок
